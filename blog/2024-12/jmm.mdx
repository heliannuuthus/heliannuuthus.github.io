---
slug: jmm
title: Java 内存模型
authors: [heliannuuthus]
tags: [Java]
unlisted: true
---

从操作系统到 JDK 具体实现，逐步了解 Java 并发编程。

<!-- truncate -->

import Image, { Center } from "@site/src/components/Image";

## Java Memory Model

> JMM(Java Memory Model) 是 Java 并发编程的基石。

### CPU 的缓存模型

CPU 每个核心都有自己的缓存，当发生写操作时，会先写入缓存中，然后由缓存通过总线通知其他 CPU 核心更新数据，我们称这种特性为**缓存一致性**。

<Center
  key="cpuCacheModelImage"
  src="https://cdn.jsdelivr.net/gh/heliannuuthus/heliannuuthus.github.io@assets/static/img/2024-12-02/CPU的缓存模型-2024-12-02-21-56-53.png"
/>

MESI 协议中定义了缓存行四种状态：

- 修改（Modified）：缓存行被修改，其他 CPU 核心的缓存行失效。
- 独享（Exclusive）：缓存行未被修改，其他 CPU 核心的缓存行失效。
- 共享（Shared）：缓存行未被修改，其他 CPU 核心的缓存行有效。
- 失效（Invalid）：缓存行失效，其他 CPU 核心的缓存行失效。

并且有以下规则：

- 当发生读操作时，会先从缓存中读取数据，如果缓存中没有数据，则从**主内存**中读取数据。
- 当发生写操作时，会先写入缓存中，然后由缓存通过**总线**通知其他 CPU 核心更新数据，其他 CPU 核心的缓存行状态会从**共享状态**变为**失效状态**。

### CPU 指令重排序

> 指令重排序是指 CPU 在执行指令时，为了提高执行效率，可能会对指令的执行顺序进行重新排列。

常见的指令重排序有三种：

- 编译器优化重排序：编译器在不改变单线程程序语义的前提下，重新安排语句的执行顺序。
- 指令并行重排序：CPU 在不影响单线程程序语义的前提下，调整指令的执行顺序。
- 内存系统重排序：由于缓存的存在，导致指令的执行顺序发生变化。

在单线程场景中，除了**内存系统重排序**，其他两种重排序都会生效，且*不会影响程序的执行结果*。
但在多线程场景中，**任何**指令重排序都可能会导致程序的执行结果不一致。

对于**编译器优化重排序**以及**指令并行重排序**，有不同的解决办法：

- 编译器优化重排序：通过禁止特定类型的编译器优化重排序来解决。
- 指令并行重排序：通过插入:term[内存屏障]{./blog/terms/java#memory-barrier}来解决。

:::info 关系说明
通常程序运行在操作系统上，而 CPU 缓存模型可以看作是操作系统上**程序与内存**的缩影。

为了解决内存一致性以及指令重排序问题，操作系统通过定义内存模型来规范程序的行为。
:::

## Java 内存模型

> JMM 也可以看作是 Java 并发编程相关的规则

### 为什么需要 JMM？

为什么 Java 需要自定义内存模型？而不是直接复用操作系统的内存模型？
不同操作系统的内存模型不一定相同，考虑到代码的**跨平台可移植性**，Java 需要自定义内存模型来*屏蔽底层操作系统的差异*。
其实对于 Java 开发者来说，只用将 JMM 看作成 Java **并发编程的规则**即可。
除了抽象出来线程与主存之间的关系，还规定 Java 的源代码转换为 CPU 指令需要遵循的规则。

### 主内存与工作内存

- 工作内存：单个线程独有，工作内存是主内存的**副本**，线程对变量的所有操作都必须在工作内存中进行，而不能直接操作主内存中的变量。
- 主内存：所有线程共享的主内存，是变量存储的**真实**位置。

### 内存间交互操作

> 用于解决并发编程中的内存一致性问题

- lock：锁定主内存中的变量，在解锁之前，其他线程无法访问该变量。
- unlock：解锁主内存中的变量，未锁定状态的变量，无法执行解锁操作。
- read：从主内存中读取变量到工作内存中，还未真正使用变量。
- load：将主内存中的变量值赋值给工作内存中的变量，此时变量才真正被使用。
- use：将工作内存中的变量值传递给执行引擎。
- assign：将执行引擎返回的值赋值给工作内存中的变量。
- store：将工作内存中的变量值写入主内存中，还未真正写入。
- write：将主内存中的变量值赋值给工作内存中的变量，此时变量真正被写入。

### happens-before 规则

> 用于解决并发编程中的指令重排序问题

1. 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。
2. 锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。
3. volatile 变量规则：对一个 volatile 变量的写操作，happens-before 于任意后续对这个 volatile 变量的读操作。
4. 传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。

:::tip

Java 内存和 Java 内存模型是两个不同的概念：

- Java 内存涵盖了堆、栈、方法区等内存区域，是真正的内存区域。
- JMM 是并发编程的一套规则，定义线程如何正确访问主内存共享变量，主要目的是简化多线程编程，提高代码跨平台的可移植性。
  :::

### 并发编程的特性

- 原子性：一个操作是不可分割的，要么全部执行，要么全部不执行。
  - `volatile` 变量、`synchronized` 代码块、`Lock` 锁、`Atomic` 原子类等。
  - `final` 并不能保证原子性，其底层实现是**内存屏障**。
- 可见性：一个线程对共享变量的修改，其他线程能够**立即**看到。
  - `volatile` 变量、`synchronized` 代码块、`Lock` 锁、`final` 变量等。
- 有序性：一个线程的执行顺序，其他线程能够**立即**看到。
  - `volatile` 变量、`synchronized` 代码块、`Lock` 锁、`final` 变量等。

### 一些常见问题

- [Java 并发编程问题总结](./juc)
