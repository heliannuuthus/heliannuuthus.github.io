---
slug: mysql
title: MySQL 复习笔记
authors: [heliannuuthus]
tags: [Web Backend]
unlisted: true
---

对 MySQL 相关知识点的复习笔记。

<!-- truncate -->

import Tabs from "@site/src/components/Tabs";
import MySQLDataTypes from "@site/src/customize/2024/MysqlDataTypes";
import Manuscript from "./_contents/mysql/manuscript.mdx";
import Machine from "./_contents/mysql/machine.mdx";
import Image, {Center} from "@site/src/components/Image";

## 架构

### 连接层

处理连接、认证授权、及相关的安全方案

### 服务层

包括查询解析、分析、优化、缓存、以及所有的内置函数

### 引擎层

数据的存储和提取

### 存储层

将数据存放在运行 MySQL 的设备的文件系统上

## 存储引擎

> 主要说一下 InnoDB 和 MyISAM

- InnoDB 支持事务，MyISAM 不支持事务（切换默认引擎的主要原因之一）。
- InnoDB 支持外键（虽然作用不大），MyISAM 不支持，若存在外键的表，将存储引擎从 InnoDB 转换为 MyISAM 会失败。
- InnoDB 是**聚簇索引**，MyISAM 是**非聚簇索引**
  - 聚簇索引：数据存放在**主键索引**下，**辅助索引**存放**主键**和**索引值**，故而，InnoDB 会将**数据和索引一起存放**，详见[索引](#索引)。
  - 非聚簇索引：**索引存放指向数据文件的指针**，主键索引和辅助索引是独立的。MyISAM 将**索引和数据分开存放**。
  - 引申：InnoDB 的表**必须有主键**，若未显示指定主键，InnoDB 会默认使用**不重复列**作为主键索引，如果不重复的列不存在，会生成一个**长度为 `INT(6)` 的隐藏列**作为主键索引。
- InnoDB 不保存数据的行数，需要执行 `select count(1) from table` 全表扫描得到行数。MyISAM 使用一个变量储存表的行数，需要访问时直接返回。
- InnoDB 最小粒度的锁是**行锁**，MyISAM 是**表锁**。MyISAM 一个更新语句会所锁整张表（切换为默认引擎的主要原因之一）。
- InnoDB 会在`BufferPool`内缓存真实的数据页和索引，对内存的要求很高。MyISAM 仅缓存索引。
- InnoDB 会将**数据和索引一起存放**，MyISAM 将**索引和数据分开存放**。

## 数据类型

<MySQLDataTypes />

> char 和 varchar 的区别：

- char 是定长字符串，varchar 是可变长度字符串
- char(n) 中表示存储的**字符**，不管实际存储多少，都会占用 n 个**字符**
- varchar(n) 中表示存储的**字节**，实际存储多少，就占用多少**字符 + 长度位（1 或 2 字节）**
  - 1 可以表示 0 ～ 255 字节，2 可以表示 256 ～ 65535 字节
- 超过 n 个字符，char 会截断，varchar 会报错
- char 最多能存储 255，并且在存储时会截断尾部的空格

## 索引

> 索引是一种高效查询的**数据结构**，索引的本质是数据表中**一列**或**多列**的值，**按一定顺序排列**

### 分类

- 主键索引：唯一标识一条记录，非空且不能重复
- 唯一索引：唯一标识一条记录，可以为空，但不能重复
- 普通索引：标识一条记录，可以为空，也可以重复
- 组合索引：将多列组合起来，建立一个索引，具备和普通索引相同的特性
- 全文索引：用于全文搜索，本质是倒排索引
  - 空间索引：用于地理空间数据类型，不做详细讨论

### 存储

> 索引本身也很大，不可能全存储在内存中，一般以**索引文件的形式存放于磁盘上**

- 聚簇索引：将数据和索引一起存放
- 非聚簇索引：将索引和数据分开存放

### 数据结构

#### B+Tree

> 仅叶子节点存放数据，并且叶子节点之间有指针相连，形成**链式环状结构**

MyISAM 和 InnoDB 都使用 B+Tree 作为索引的数据结构，相较于 B-Tree，B+Tree 的**叶子节点之间有指针相连，形成链式环状结构**，并且**数据仅存放在叶子节点**。

#### B-Tree

> B-Tree 的所有节点都存放数据

核心是为磁盘等外存储设备设计的一种平衡搜索树，所有节点都可存放数据页。
系统从磁盘加载数据到内存时，是以 **块（block）** 为单位，每次读取都是固定大小的数据（多个块）。
InnoDB 将数据加载到 `BufferPool` 中是以配置的 `innodb_page_size` 为单位，按页加载（默认 16KB，远大于 block 的值）。

#### Hash

> 存储结构单一，常用于等值查询，范围查询需要扫表

按 key-value 形式存储，key 唯一，value 为数据地址。

> 为什么 InnoDB 推荐使用自增的 id 作为主键？

- 自增 id 的插入性能优于随机 id
- 插入时需要做比较，自增 id 比随机 id 快
- 随机 id 的数据读取是随机访问的，在条件范围查询时加载的页数多，会多次进行磁盘 IO
- 随机 id 的插入可能会导致 B+Tree 分裂重构，消耗更多的时间，而自增 id 仅会在叶子节点的最尾部插入，不会导致 B+Tree 分裂重构

> 为什么非主键索引结构叶子节点存放的是主键值？

- 用作索引的数据列，通常情况下不会发生改变
- 当需要改变的数据发生改变时，仅用通过非主键索引找到主键，再修改对应的数据即可

### 优化

- 索引覆盖：查询的列都是索引列，即不会回表查询
- 索引下推：查询索引列做判断，过滤掉不符合条件的记录，减少回表次数
- 最左前缀原则：复合索引的查询条件必须从最左列开始，否则无法使用索引
- 前缀索引：对字符串的前 n 个字符建立索引，可以减少索引长度，提高查询效率

## 查询

### 执行流程

<Tabs
  items={[
    {
      label: "手写语句",
      key: "manuscript",
      children: <Manuscript />,
    },
    {
      label: "实际执行",
      key: "machine",
      children: <Machine />,
    },
  ]}
/>

### 查询连接

- 内连接：仅返回符合条件的记录
- 外连接：返回符合条件的记录，以及不符合条件的记录
- 左连接：返回符合条件的记录，以及左表中不符合条件的记录
- 右连接：返回符合条件的记录，以及右表中不符合条件的记录

## 事务

### ACID

- 原子性（Atomicity）：事务是最小的不可分割的工作单元，事务中的所有操作，要么全部成功，要么全部失败
- 一致性（Consistency）：事务执行前后，数据保持一致
- 隔离性（Isolation）：多个事务并发执行时，事务之间互不干扰
- 持久性（Durability）：事务一旦提交，对数据库的改变就是永久性的

### 并发问题

- 更新丢失：两个事务修改同一条数据，由于事务隔离性，**后提交的事务会覆盖先提交的事务**，会导致更新丢失
- 脏读：一个事务读取到另一个事务**修改/新增的且未提交的数据**，当这个事务回滚时，当前事务读取到的数据是无效的
- 不可重复读：一个事务多次读取一条数据时，读取到另一个事务已经**提交的修改的数据**，导致读取前后的数据不一致
- 幻读：一个事务多次读取一条数据时，读取到另一个事务已经**提交的新增或删除的数据**，导致读取前后的数据丢失

### 隔离级别

- 读未提交：允许读取尚未提交的数据，最低的隔离级别
- 读已提交：允许事务并发读取已经提交的数据，可阻止脏读，但是幻读和不可重复读无法阻止
- 可重复读：一个事务内，对同一数据字段，多次读取到的数据是一致的，可阻止脏读和不可重复读，无法阻止幻读
- 串行化：一个事务在执行时，其他的事务必须等待，直到该事务执行完毕，可阻止脏读、不可重复读和幻读

:::tip

InnoDB 默认隔离级别为**可重复读**，但由于 InnoDB 实现**可重复读**算法的特殊性，在实际使用中和能完全保证事务的隔离性要求，达到了**串行化**的效果。

:::

## 多版本并发控制（MVCC）

> 通过悲观和乐观两种并发控制策略，来保证事务的隔离性和一致性

> MySQL 大多数事务型存储引擎都不是简单的使用行锁。出于对性能的考虑，几乎都实现了多版本并发控制。

- MVCC 可视为**行锁的变种**，针对**读操作不加锁**，**写操作只加行锁**
- 针对不同的隔离级别，实现 MVCC 的方式不同
  - 在 RR 隔离级别下是通过保存**事务开始时间的数据快照**，后续的快照读都基于该快照
  - 在 RC 隔离级别下使用[**当前读**](#快照读和当前读)
- 分为**乐观并发控制**和**悲观并发控制**

### 快照读和当前读

- 快照读：获取事务开始时的数据快照，无锁
  - 在 RR 和 RC 隔离级别下，普通的 `select ...` 是快照读，根据[ReadView](#readview)判断数据是否可见
- 当前读：读取的是当前数据，可能会读取到其他事务提交的数据，加锁
  - 在 RR 和 RC 隔离级别下，`select ... for update` 和 `select ... lock in share mode` 是当前读，意在读取当前最新的数据，和 [ReadView](#readview) 无关

### ReadView

> 在 RC 级别下多次快照读多次生成 ReadView，在 RR 级别下仅在事务开始时生成一次 ReadView

#### 变量声明

- `up_limit_id`：记录事务开始时，活跃事务的最大事务 ID
- `low_limit_id`：记录事务开始时，活跃事务的最大事务 ID + 1
- `trx_ids`：记录事务开始时，活跃事务的事务 ID

#### 数据行是否可见的规则

- 如果数据行的事务 ID 小于 `up_limit_id`，则数据行可见
- 如果数据行的事务 ID 大于等于 `low_limit_id`，则数据行不可见
- 如果数据行的事务 ID 在 `trx_ids` 中，则需要根据事务 ID 是否在 `trx_ids` 中来判断数据行是否可见

### Replitable Read 的 MVCC

- 通过两个隐藏列：`DB_TRX_ID` 和 `DB_ROLL_PTR` 来实现 MVCC
  - `DB_TRX_ID`：开启事务时，将事务 ID 自增并填入该列
  - `DB_ROLL_PTR`：回滚指针，指向该行被修改前的数据

## 日志系统

- undo log: 保证事务的**原子性**，即要么全部成功，要么全部失败
- redo log: 保证事务的**持久性**，数据发生修改之前会先记录在 redo log 中，由后台线程刷到磁盘上
- binlog:

### undo log

> undo log 保证了事务的**原子性**，即要么全部成功，要么全部失败

- 在事务创建时，会为当前事务分配 **undo log segment**（undo log 存储的基本单元）
- undo log 中记录的操作和事务执行的操作是相反的
  - INSERT VALUE -> DELETE VALUE
  - UPDATE VALUE1 SET VALUE2 -> UPDATE VALUE1 SET VALUE1
- 当前事务提交之后，如果其他的事务依赖当前事务的 undo log，则当前事务的 undo log 不会被删除，直到依赖的事务提交才会被 purge 线程删除

<Center
  key="undoLogImage"
  src="https://cdn.jsdelivr.net/gh/heliannuuthus/heliannuuthus.github.io@assets/static/img/2025-01-13/RR-ReadView-2025-01-13-21-29-08.png"
/>
